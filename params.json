{
  "name": "Rails BDD test practices",
  "tagline": "Notes about testing practices",
  "body": "<a rel=\"license\" href=\"http://creativecommons.org/licenses/by-sa/4.0/\"><img alt=\"Creative Commons License\" style=\"border-width:0\" src=\"https://i.creativecommons.org/l/by-sa/4.0/88x31.png\" /></a><br />This work is licensed under a <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-sa/4.0/\">Creative Commons Attribution-ShareAlike 4.0 International License</a>.\r\n\r\n## Tools\r\n* Use SimpleBDD\r\n  *  Cucumber leads to 'early dried' tests\r\n  *  Cucumber leads to conditionals in step definitions\r\n  *  Devs have an unhealthy focus on making step definitions reusable.\r\n\r\n# Wet vs. DRY\r\nTest's should not be very dry. *WET* tests allow you to continually learn about your system, and understand the impact of feature changes.\r\n\r\nFor example. \r\n\r\n0. You have eight tests that describe the user registration process.\r\n0. The progression through the process is dried up in Step Definitions or a helper.\r\n0. You change conditional to show a confirmation dialog and edit the test helper to match.\r\n0. You miss the fact that in one of the other tests, the user should still see the dialog. \r\n\r\nThe problem is hidden because the test helper provided no context about the different scenarios.\r\n\r\nSome *DRY* guidelines:\r\n\r\n* Carefully DRY **backgrounds and stubs**\r\n  * Stubs often need to change because of the test\r\n  * Once DRYed stubs are harder to rework\r\n  * This is true of Factories too\r\n  * If you do use DRY tools for backgrounds, make sure they're flexible (IE. FactoryGirl)\r\n* Carefully DRY Givens\r\n\t* Make sure that the state in a given is 'wet' tested. E.g. If the given is 'a user is logged in' there must also be a 'User logs in' Feature.\r\n\t* Same rule applies as backgrounds and stubs\r\n* Don't dry up behaviours (When)\r\n  * These are the actions you care about. Don't hide the cause away with indirection!\r\n  * Except:\r\n    * code to drive the system, IE Capybara.\r\n* Don't dry up expectations (Then)\r\n\r\n## Feature files\r\n* Write short features about the story you implement.\r\n* If all your stories 'travel' through your system\r\n  * They will be slow\r\n  * They will not be focused on the *stand-out* aspects of the feature\r\n  * They will get cumbersome and you'll be inclined to dry up, and thus hide, important details.\r\n\r\nInstead, establish a background at the start of test and mitigate the risk that the whole story is not played out by:\r\n  * Use a smoke test for important paths through the system\r\n  * Make sure you have a travelling test for your background.\t\r\n\r\n\r\nFor example, the following test is focused on the action of getting the \"widget app\".\r\n\r\n```\r\nFeature: 'Downloading our awesome widget app'\r\nGiven John is logged in\r\nWhen he visits the download page\r\nAnd he downloads the widget app\r\nThen he has our awesome widget app \r\n```\r\n\r\nThere is no evidence that he can register and log in to do so. That's ok, so long as a test exists for `A user registers with the site` and `A registered yser can log in`.\r\n\r\nIt is possible that between `Register` and `Login` and between `Login` and `Download` that something could change and invalidate a test. Perhaps the download link no longer appears on the page you see after login. This is where you do need **travelling** tests.\r\n\r\n## Smoke and travelling tests\r\n* Write long 'travelling tests' about the important aspects of the application.\r\n  * Try and run these against production \r\n    * Actual live site if you have a single important instance\r\n    * Clones or emulations of likely production environments if users install your software.\r\n  * Also run them before committing your code to your main branch.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}